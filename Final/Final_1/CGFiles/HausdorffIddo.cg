
#define MAX_ORDER 10
#define UV_STOP_TOLERANCE 0.01

// Evaluating Bez crv (up to order MAX_ORDER) - storing only three points needed for
// evaluating derivs (not all subdivided crvs)
void EvalBezCrv(float4 crv[MAX_ORDER], 
                int ordT, 
                float t, 
                out float4 ct,
                out float4 ctLeft,
                out float4 ctRight)
{
	float4 crvAux[MAX_ORDER];
	float4 crvAuxTmp[MAX_ORDER];
	int i,j;
	for (i=0; i<ordT; ++i) 
		crvAux[i] = crv[i]; //copy crv to crvAux (maybe can work directly on crv if we copy from outside)
	for (i=1; i<ordT-1; ++i)
	{
		for (j=0; j<ordT-i; ++j) {
			crvAuxTmp[j] = lerp(crvAux[j], crvAux[j+1], t);
		}
		for (j=0; j<ordT-i; ++j) {
			crvAux[j] = crvAuxTmp[j]; //copy auxTmp to aux
		}
	}
	//when reaching here, crvAux[0],crvAux[1] should hold cuLeft and cuRight
	ctLeft = crvAux[0];
	ctRight = crvAux[1];
	ct = lerp(ctLeft, ctRight, t);
}

// Returns surface evaluation and partial derivitives at (u,v).
// Note that if surface is rational the actual partial derivative computation
// should use the formula (Su*w-S*wu)/w^2 
void EvalBezSrf(uniform samplerRECT surface2Cps, 
                int ordU, int ordV,
                float u, float v,
                out float4 S,
                out float4 Su,
                out float4 Sv)
{
	int i,j;
	float4 c[MAX_ORDER];
	float4 cL[MAX_ORDER];
	float4 cR[MAX_ORDER];
	for (i=0; i<ordU; ++i) {
		float4 crv[MAX_ORDER];
		for (j=0; j<ordV;++j) {
			float4 cpij = texRECT(surface2Cps, float2(i+0.5,j+0.5));
			crv[j] = cpij;
		}
		float4 cv, cvL, cvR;
		EvalBezCrv(crv,ordV,v, cv, cvL, cvR);
		c[i] = cv;
		cL[i] = cvL;
		cR[i] = cvR;
	}

	float4 cuL, cuR;
	EvalBezCrv(c, ordU, u, S, cuL, cuR);
	Su = ordU*(cuR-cuL);

	float4 c1, c_1, c1L, c1R;
	EvalBezCrv(cR, ordU, u, c1, c1L, c1R);
	EvalBezCrv(cL, ordU, u, c_1, c1L, c1R);
	Sv = ordV*(c1-c_1);
}


// Projecting a point pt onto the tangent plane at (u,v) resulting in du,dv
// du = <p-S(u,v),Su>/<Su,Su>
// dv = <p-S(u,v),Sv>/<Sv,Sv>
void PointProjectOnTangentPlane(float3 pt, uniform samplerRECT surface2Cps, 
                int ordU, int ordV,
                float u, float v,
                out float du,
                out float dv)
{
	// Assume rational surface:
	float4 rS, rSu, rSv;
	EvalBezSrf(surface2Cps, ordU, ordV, u, v,
				rS, rSu, rSv);

	float3 S, Su, Sv;
	//iddo - in the future possibly optimize for non-rational surfaces
	S = rS.xyz / rS.w;
	Su = (rS.w*rSu.xyz - rSu.w*rS.xyz)/(rS.w*rS.w);
	Sv = (rS.w*rSv.xyz - rSv.w*rS.xyz)/(rS.w*rS.w);

	//Project onto plane and use barycentric coordinates (computed with area ratios)
	//1. Projecting pt onto plane
	float3 SuxSv = cross(Su,Sv);
	float3 pr = pt - (dot(pt-S,SuxSv)/dot(SuxSv,SuxSv))*SuxSv;
	//du = SignedAreaOfTriangle(pr, S+Sv, S)/SignedAreaOfTriangle(S,S+Su,S+Sv);
	//dv = SignedAreaOfTriangle(pr, S, S+Su)/SignedAreaOfTriangle(S,S+Su,S+Sv);
	float3 prSxSv = cross(pr-S,Sv);
	du = length(prSxSv)/length(SuxSv);
	if (dot(prSxSv,SuxSv) < 0)
		du = -du;
	float3 SuxprS = cross(Su,pr-S);
	dv = length(SuxprS)/length(SuxSv);
	if (dot(SuxprS,SuxSv) < 0)
		dv = -dv;
}


void main(  float2 coords		: TEXCOORD0,
			uniform samplerRECT surface1Pts		: TEXUNIT0,
			uniform samplerRECT surface2Cps		: TEXUNIT1,
			uniform samplerRECT prevDists : TEXUNIT2,
			uniform int ordU,
			uniform int ordV,
			out float4 oColor : COLOR)
{
	float4 pt = texRECT(surface1Pts, coords);

	float4 cp = texRECT(surface2Cps, float2(0.5,0.5));
	float dist = distance(pt,cp);
	float i0=0, j0=0;

	// Finding an initial guess by going over the control mesh
	//(iddo: need to test if this slows down the shader and maybe using midpoint is better)
	for (int i=0; i<ordU; ++i) {
		for (int j=0; j<ordV;++j) {
			float4 cpij = texRECT(surface2Cps, float2(i+0.5,j+0.5));
			float tmp = distance(pt,cpij);
			if (tmp < dist) {
				dist = tmp;
				cp = cpij;
				i0 = i; j0=j;
			}		
		}
	}

	// Once we are here, we have an initial i0,j0:
	float u = float(i0)/float(ordU-1);
	float v = float(j0)/float(ordV-1);
	float3 p = pt.xyz;
	if (pt.w != 1.0) p = p/pt.w;
	int dbg = 0; //debug variable

	//NR iteration:
	for (int iter=0; iter<4; ++iter)
	{
		float du, dv;
		PointProjectOnTangentPlane(p, surface2Cps, 
					  ordU, ordV,
					  u, v,
					  du, dv);
		//stopping criterion
		if (abs(du) < UV_STOP_TOLERANCE && abs(dv) < UV_STOP_TOLERANCE) {
			//iddo: possibly compare dist to previous iteration as an additional stopping criterion
			dbg = 1;
			break;
		}
		else {
			u += du;
			if (u > 1.0) u = 1.0;
			if (u < 0.0) u = 0.0;
			v += dv;
			if (v > 1.0) v = 1.0;
			if (v < 0.0) v = 0.0;
		}
	}
	// Evaluate the distance from the projected point
	float4 S, Su, Sv;
	EvalBezSrf(surface2Cps, ordU, ordV, u, v, S, Su, Sv); //no need, done in projection
	dist = distance(pt,S);  

	//iddo: possibly also perform distance NR on boundary curves (looks like it's not needed)

	float4 prevPt = texRECT(prevDists, coords);
	if (dist < prevPt.w) {
		oColor = S;
		//iddo debug
		//if (dbg==1) oColor.z = -9999;
		oColor.w = dist;
	}
	else {
		oColor = prevPt;
	}
} 
